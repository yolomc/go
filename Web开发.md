## RESTful

##### REST是一种统一的接口定义。`HTTP/1.1`协议中共定义了9种HTTP请求方法，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。

#### `GET`

`GET`会方法请求指定的页面信息，并返回响应主体，`GET`被认为是不安全的方法，因为`GET`方法会被网络蜘蛛等任意的访问。

#### `HEAD`

`HEAD`方法与`GET`方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应`HEAD`请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。`HEAD`方法常被用于客户端查看服务器的性能。

#### `POST`

`POST`请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。常用于数据的提交，新增操作。

#### `PUT`

`PUT`请求会向指定资源位置上传其最新内容，侧重于对于数据的修改操作。

#### `DELETE`

`DELETE`请求用于请求服务器删除所请求`URI`（统一资源标识符，Uniform Resource Identifier）所标识的资源。`DELETE`请求后指定资源会被删除。

#### `CONNECT`

`CONNECT`方法是`HTTP/1.1`协议预留的，能够将连接改为管道方式的代理服务器。通常用于[SSL](http://itbilu.com/other/relate/N16Uaoyp.html)加密服务器的链接与非加密的HTTP代理服务器的通信。

#### `OPTIONS`

`OPTIONS`请求与`HEAD`类似，一般也是用于客户端查看服务器的性能。 这个方法属于浏览器的预检请求，查看服务器是否接受请求，预检通过后，浏览器才会去发get，post，put，delete等请求。JavaScript的[XMLHttpRequest](http://itbilu.com/javascript/js/VkiXuUcC.html)对象进行`CORS`跨域资源共享时，就是使用`OPTIONS`方法发送嗅探请求，以判断是否有对指定资源的访问权限。 

#### `TRACE`

`TRACE`请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

#### `PATCH`

`PATCH`方法出现的较晚(2010年)。`PATCH`请求与`PUT`请求类似，同样用于资源的更新。二者有以下两点不同：

- `PATCH`一般用于资源的部分更新，而`PUT`一般用于资源的整体更新。
- 当资源不存在时，`PATCH`会创建一个新的资源，而`PUT`只会对已在资源进行更新。





## HTTP/HTTPS、TCP/IP

### 七层网络模型

| OSI模型                     | 协议                       | 描述                                                         |
| --------------------------- | -------------------------- | ------------------------------------------------------------ |
| 应用层(Application Layer)   | HTTP、FTP、SMTP、DNS等协议 | 应用程序，生成http数据包                                     |
| 表示层(Presentation Layer)  | ...                        | 数据处理，是否加密                                           |
| 会话层(Session Layer)       | ...                        | 建立、管理、终止连接，证书验证                               |
| 传输控制层(Transport Layer) | TCP、UDP协议               | http数据包嵌入到 **TCP数据包**：头部(标识着收发双方的端口信息) + HTTP数据包 |
| 网络层(Network Layer)       | IP、ICMP协议               | 通过路由表(route)定位 下一跳/网关(gateway) IP。TCP数据包嵌入到 **IP数据包**：头部（双方IP地址信息）+ TCP数据包 |
| 数据链路层(Data Link Layer) | ARP协议                    | 根据下一跳/网关IP 通过ARP协议 定位到目标mac地址。IP数据包嵌入到**数据帧(以太网数据包)**：头部(双方MAC地址)+ IP数据包组成 |
| 物理层(Physical Layer)      | ...                        | 通过网卡、网线等物理设备发送数据                             |

![](https://img-blog.csdn.net/20180719094756330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![OSI网络模型及其协议图](https://images2017.cnblogs.com/blog/1200992/201711/1200992-20171113211443656-1388922018.png)

TCP/IP是一种面向连接的可靠的传输协议，主要解决数据如何在网络中传输。HTTP、FTP等协议是构建于TCP/IP协议之上的，主要解决如何包装数据。

连接具体指：c和s三次握手后，并各自在内存中开辟了相对应的资源为当前连接服务，此时双方建立了连接。

[TCP三次握手、四次挥手出现意外情况时，如何保证稳定可靠？](https://mp.weixin.qq.com/s/3ggvJNRyw8xDr_qwLt9Nxw)

[Ping 的过程](https://mp.weixin.qq.com/s/SpsLmoET42Tx2gIGpESa-A)



## TCP和UDP的区别：

TCP是面向连接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性;而UDP不是面向连接的。

UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。



## HTTP 1.0、1.1、2.0的区别

| HTTP1.1                                          | HTTP2                  | QUIC                                            |
| ------------------------------------------------ | ---------------------- | ----------------------------------------------- |
| 持久连接                                         | 二进制分帧             | 基于UDP的多路传输（单连接下）                   |
| 请求管道化                                       | 多路复用（或连接共享） | 极低的等待时延（相比于TCP的三次握手）           |
| 增加缓存处理（新的字段如cache-control）          | 头部压缩               | QUIC为 传输层 协议 ，成为更多应用层的高性能选择 |
| 增加Host字段、支持断点传输等（把文件分成几部分） | 服务器推送             |                                                 |



## HTTP和HTTPS 

HTTP连接就是所谓的短连接，即客户端向服务器端发送一次请求(三次握手)，服务器端响应后连接即会断掉(四次挥手)。HTTP请求的缺点：请求信息明文传输，容易被窃听截取；数据的完整性未校验，容易被篡改；没有验证对方身份，存在冒充危险；

HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL/TLS证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

HTTPS 建立连接的过程 （使用HTTPS请求的前提是需要保证服务端配置正确了对应的安全证书）：

```
1. 客户端发送客户端支持的加密协议及版本到服务端
2. 服务端接收到请求后，与自身支持的加密协议相对比，从中筛选出合适的加密协议。如果不支持则连接断开。
3. 服务端返回一个（CA机构颁布给服务端的）数字证书给客户端。数字证书中包含 （非对称加密）公钥、证书颁发机构、网站地址、失效日期等
4. 客户端接收到数字证书后（通过操作系统内置的根证书）进行校验，如果校验通过或者用户接受了不受信任证书，浏览器会生成一个随机数（对称加密密钥）,使用（收到的的）非对称加密公钥对其加密，发送到服务端
5. 服务端接收到密文后，用（本地的）非对称加密私钥对其解密得到客户端生成的随机数（对称加密密钥）,并向客户端发送确认信息。
6. 此时客户端和服务端都持有对称加密的私钥，SSL加密连接建立。
```

![](https://img2018.cnblogs.com/blog/163758/201904/163758-20190420232308989-1115206953.png)

浏览器客户端访问同一个https服务器，可以不必每次都进行完整的TLS Handshake。服务器维护一个以**session ID**为索引的结构体，用于临时存放session key，并在**TLS handshake 阶段分享给浏览器**。当浏览器重新连接https 服务器时，TLS handshake 阶段，出示自己的session ID，**服务器获得session ID，以此为索引，可以获得和该浏览器共同拥有的session key，使用session key可以直接对用户流量做加密/解密动作。**



## Socket(四元组：Local Address[ip:sort] + Foreign Address[ip:sort])

Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（操作系统提供的API），通过Socket，我们才能使用TCP/IP协议。 socket 可以脱离于应用层，直接通过传输层协议 (TCP、UDP) 进行连接

## WebSocket

WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。

- WebSocket是一种在单个TCP连接上进行全双工通信的协议
- WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据
- 在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输

websocket是前后端交互的长连接，前后端也都可能因为一些情况导致连接失效并且相互之间没有反馈提醒。因此为了保证连接的可持续性和稳定性，websocket **心跳重连**就应运而生。在使用原生websocket的时候，如果设备网络断开，不会触发websocket的任何事件函数，前端程序无法得知当前连接已经断开。这个时候如果调用websocket.send方法，浏览器就会发现消息发不出去，便会立刻或者一定短时间后（不同浏览器或者浏览器版本可能表现不同）触发onclose函数。后端websocket服务也可能出现异常，连接断开后前端也并没有收到通知，因此需要前端定时发送心跳消息ping，后端收到ping类型的消息，立马返回pong消息，告知前端连接正常。如果一定时间没收到pong消息，就说明连接不正常，前端便会执行重连。为了解决以上两个问题，**以前端作为主动方，定时发送ping消息，用于检测网络和前后端连接问题。一旦发现异常，前端持续执行重连逻辑，直到重连成功。**



## WebAPI 和 WebService

WebApi：HTTP协议，简单轻量无状态

WebService ：soap协议，通常是跨平台的



## SOAP与HTTP的区别

**都是底层的通信协议，请求包的格式不同，soap包是XML格式,http纯文本格式**

SOAP：简单对象访问协议       http是标准超文本传输协议

SOAP可以传递结构化的数据，http只能传输纯文本数据；

SOAP相对http（post/get）由于要进行xml解析，速度可能会有所降低。 



## 301和302

301: Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。

302 Found 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

## 401和403

401 Unauthorized响应应该用来表示缺失或错误的认证；

403 Forbidden响应应该在401之后用，当用户被认证后，但用户没有被授权在特定资源上执行操作.

## 500和504

500的错误通常是由于服务器上代码出错或者是抛出了异常.

502即 Bad Gateway网关(这里的网关是指CGI,即通用网关接口)错误,通常是程序空指针错误。

504即Gateway timeout,即超时错误.



## 用户认证 Authentication/OAuth/JWT(JSON Web Token)

[一分钟带你了解JWT认证](https://www.toutiao.com/i6756013001653879304/)



## 安全与加密

##### CSRF攻击 

##### 输入过滤

##### XSS攻击

##### SQL注入

##### 存储密码

##### 加密解密

RAS、AES、DES加密



### api安全

