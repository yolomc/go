# golang 知识点



## Array 数组

1. 数组：是同一种数据类型的固定长度的序列。

2. 数组定义：`var a [len]int`，比如：`var a [5]int`，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。

3. 长度是数组类型的一部分，因此 `var a[5] int` 和 `var a[10]int` 是不同的类型。

4. 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是 `len-1`
   
    ```go
    for i := 0; i < len(a); i++ {
    }
    for index, v := range a {
    }
    ```
    
5. 访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic

6. 数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。

7. 支持 "=="、"!=" 操作符，因为内存总是被初始化过的。

8. 指针数组 `[n]*T`，数组指针 `*[n]T`。



## Slice 切片

1. 切片底层引用这一个数组对象，因此切片是引用类型。
2. 切片的长度可以改变，因此，切片是一个可变的数组。
3. 切片遍历方式和数组一样，可以用 `len()` 求长度。表示可用元素数量，读写操作不能超过该限制。 
4. `cap` 可以求出 `slice` 最大扩张容量，不能超出数组限制。`0 <= len(slice) <= len(array)`，其中 `array` 是 `slice` 引用的数组。
5. 切片的定义：`var` 变量名 `[]` 类型，比如 `var str []string` 、 `var arr []int`。
6. 如果 `slice == nil`，那么 `len`、`cap` 结果都等于 0。



## Map  哈希表

Map 是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。



## Closure 闭包

返回一个（涉及到外层变量的引用）函数，所以这个函数返回结果是受到外层变量影响的。



## interface 接口

##### 接口（interface）是一种抽象的类型。

`interface` 是一组 `method` 的集合，是 `duck-type programming` 的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。

一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。



## reflect 反射

反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。

支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。



## goroutine 协程

Go语言的并发是基于 `goroutine` 的，`goroutine` 类似于线程，但并非线程。可以将 `goroutine` 理解为一种虚拟线程。Go 语言运行时会参与调度 `goroutine`，并将 `goroutine` 合理地分配到每个 CPU 中，最大限度地使用CPU性能。开启一个goroutine的消耗非常小（大约2KB的内存），你可以轻松创建数百万个`goroutine`。

`goroutine`的特点：

```
1.`goroutine`具有可增长的分段堆栈。这意味着它们只在需要时才会使用更多内存。
2.`goroutine`的启动时间比线程快。
3.`goroutine`原生支持利用channel安全地进行通信。
4.`goroutine`共享数据结构时无需使用互斥锁。
```



## Channel 管道

1. 缓冲区。
2. Workpool (goroutine池)
3. Select



## Lock 锁

1. sync.Mutex 互斥锁，读和写使用场景差不多，可以用这个
2. sync.RWMutex 读写互斥锁，读的使用场景远远大于写的使用场景，可以用读写锁
3. sync.WaitGroup
4. sync.Once     某些高并发场景下只需要执行一次的操作，如加载文件、关闭channel



## 延迟调用与异常处理 (defer、panic、recover)

##### Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。一般是抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。

1. 利用recover处理panic指令，defer 必须放在 panic 之前定义，另外 recover 只有在 defer 调用的函数中才有效。否则当panic时，recover无法捕获到panic，无法防止panic扩散。
2. recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。
3. 多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。



## 单元测试

`go test` 是 go语言自带的测试工具， `go test`命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以`_test.go`为后缀名的源代码文件都是 `go test` 测试的一部分，不会被`go build` 编译到最终的可执行文件中。

`go test` 命令会遍历所有的`*_test.go`文件中符合命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。



## gin、beego、gorm 

## MPG、CSP、 高并发、微服务、爬虫等

