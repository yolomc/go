# golang 知识点



### [图解 Go 程序是怎样跑起来的](https://www.toutiao.com/i6709265576511930894/)

[Go 为什么这么快](https://mp.weixin.qq.com/s/ihJFa5Wir4ohhZUXVSBvMQ)



## 可排序、可比较、不可比较与不可寻址

- 可排序的数据类型有三种，Integer，Floating-point，和String
- 可比较的数据类型除了上述三种外，还有Boolean，Complex，Pointer，Channel，Interface和Array
- 不可比较的数据类型包括，Slice, Map, 和Function
- 两个不同的struct属于不同的两种类型，不能直接比较。但如果两种struct内部结构相同且不包含不可比较的元素，则在强转成同一struct后可以比较。
- 不可寻址：常量、值、算术操作的结果、切片结果和索引（包括数组、切片和map的索引。但有一例外：**切片字面量的索引结果值**是可寻址的）、函数、结构体的字段和方法 【参考：https://github.com/hyper0x/Golang_Puzzlers/blob/master/src/puzzlers/article15/q1/demo35.go】

## 字节占用

在64位系统下，Golang的切片占用字节是24位，map和struct都是8位.



## Array 数组

1. 数组：是同一种数据类型的固定长度的序列。

2. 数组定义：`var a [len]int`，比如：`var a [5]int`，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。

3. 长度是数组类型的一部分，因此 `var a[5] int` 和 `var a[10]int` 是不同的类型。

4. 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是 `len-1`
   
    ```go
    for i := 0; i < len(a); i++ {
    }
    for index, v := range a {
    }
    ```
    
5. 访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic

6. 数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。

7. 支持 "=="、"!=" 操作符，因为内存总是被初始化过的。

8. 指针数组 `[n]*T`，数组指针 `*[n]T`。



## Slice 切片

1. 切片底层引用这一个数组对象，因此切片是引用类型。
2. 切片的长度可以改变，因此，切片是一个可变的数组。
3. 切片遍历方式和数组一样，可以用 `len()` 求长度。表示可用元素数量，读写操作不能超过该限制。 
4. `cap` 可以求出 `slice` 最大扩张容量，不能超出数组限制。`0 <= len(slice) <= len(array)`，其中 `array` 是 `slice` 引用的数组。
5. 切片的定义：`var` 变量名 `[]` 类型，比如 `var str []string` 、 `var arr []int`。
6. 如果 `slice == nil`，那么 `len`、`cap` 结果都等于 0。

在对slice进行append等操作时，可能会造成slice的自动扩容。其扩容时的大小增长规则是：

- 如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。
- 如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。



## Map  哈希表

Map 是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。

struct可以作为map的key么？struct必须是可比较的才能作为key，否则编译时报错。

如何排序：遍历map把key存到slice中进行排序



## Struct  结构体

struct {}是一个无元素的结构体类型，通常在没有信息存储时使用。优点是大小为0，不需要内存来存储struct {}类型的值。struct {} {}是一个复合字面量，它构造了一个struct {}类型的值，该值也是空。



## Closure 闭包

返回一个（涉及到外层变量的引用）函数，所以这个函数返回结果是受到外层变量影响的。



## Defer  延迟函数

defer 是 Go 语言提供的一种用于注册延迟调用的机制，每一次 defer 都会把函数压入栈中，(Defer所在的)当前函数返回前再把延迟函数取出并执行。

defer 语句定义时，对外部变量的引用是有两种方式的，分别是作为**函数参数**和作为**闭包引用**。作为函数参数，则在 defer 定义时就把值传递给 defer，并被缓存起来；作为闭包引用的话，则会在 defer 函数真正调用时根据整个上下文确定当前的值。

```go
//避免掉坑的关键是要理解这条语句：
return xxx

//这条语句并不是一个原子指令，经过编译之后，变成了三条指令：
1. 返回值 = xxx
2. 调用 defer 函数
3. 空的 return
//第 1,3 步才是 return 语句真正的命令，第 2 步是 defer 定义的语句，这里就有可能会操作返回值。
```



[5 年 Gopher 都不知道的 defer 细节](https://mp.weixin.qq.com/s/Hm8MdrqYgCQPQ4A1nrv4sw)



## interface 接口

##### 接口（interface）是一种抽象的类型。

`interface` 是一组 `method` 的集合，是 `duck-type programming` 的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。

一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。



## reflect 反射

反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。

支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。



## goroutine 协程

Go语言的并发是基于 `goroutine` 的，`goroutine` 类似于线程，但并非线程。可以将 `goroutine` 理解为一种虚拟线程。Go 语言运行时会参与调度 `goroutine`，并将 `goroutine` 合理地分配到每个 CPU 中，最大限度地使用CPU性能。开启一个goroutine的消耗非常小（大约2KB的内存），你可以轻松创建数百万个`goroutine`。

`goroutine`的特点：

1.`goroutine`具有可增长的分段堆栈。这意味着它们只在需要时才会使用更多内存。
2.`goroutine`的启动时间比线程快。
3.`goroutine`原生支持利用channel安全地进行通信。
4.`goroutine`共享数据结构时无需使用互斥锁。

### goroutine的退出，泄露

使用runtime.Stack在测试代码运行前后计算goroutine数量，当然我理解测试代码运行完成之后是会触发gc的。如果触发gc之后，发现还有goroutine没有被回收，那么这个goroutine很有可能是被泄漏的。

通过GOMAXPROCS可以查看Goroutine的数量。



## Channel 管道

如果说 `goroutine` 是Go程序并发的执行体，`channel` 就是它们之间的连接。`channel` 是可以让一个 `goroutine` 发送特定值到另一个 `goroutine` 的通信机制。Channel是异步进行的。

1. 缓冲区

   ​		无缓冲的通道必须有接收才能发送。无缓冲通道上的发送操作会阻塞，直到另一个`goroutine` 在该通道上执行接收操作，这时值才能发送成功，两个 `goroutine` 将继续执行。相反，如果接收操作先执行，接收方的 `goroutine` 将阻塞，直到另一个 `goroutine` 在该通道上发送一个值。使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。

   ​		通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。

2. Workpool (goroutine池)

   ​		无休止的开辟 `goroutine` 会出现高频率的调度 `groutine`，那么依然会浪费很多上下文切换的资源，导致做无用功。所以设计一个 `goroutine` 池限制 `goroutine` 的开辟个数在大型并发场景还是必要的。

3. Select (多路复用)

   ​		在某些场景下我们需要同时从多个channel接收数据。`select` 会等待 `case` 中有能够执行的 `case` 时去执行。当条件满足时，`select` 才会去通信并执行`case` 之后的语句，这时候其它通信是不会执行的。 如果多个`case` 同时就绪时，`select` 会随机地选择一个执行。当监听的多个 `case` 都阻塞住会执行default的逻辑。



## Lock 锁

1. sync.Mutex 互斥锁，读和写使用场景差不多，可以用这个
2. sync.RWMutex 读写互斥锁(可以同时读，但是读-写，写-写都是互斥的)，读的使用场景远远大于写的使用场景，可以用读写锁
3. sync.WaitGroup 内部维护着一个计数器，通过计数器值的增加和减少实现并发任务的同步。
4. sync.Once 某些高并发场景下只需要执行一次的操作，如加载文件、关闭channel
5. sync.Map 是一个开箱即用的并发安全版的Map (Go语言中内置的map不是并发安全的)。

死锁产生的四个必要条件:

1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。



## context 上下文

context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。

Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。

Context中的方法:

- Done会返回一个channel，当该context被取消的时候，该channel会被关闭，同时对应的使用该context的routine也应该结束并返回。
- Context中的方法是协程安全的，这也就代表了在父routine中创建的context，可以传递给任意数量的routine并让他们同时访问。
- Deadline会返回一个超时时间，routine获得了超时时间后，可以对某些io操作设定超时时间。
- Value可以让routine共享一些数据，当然获得数据是协程安全的。



## go init 的执行顺序

不按导入规则的（这里是编译时按文件名的顺序执行的）？



## 延迟调用与异常处理 (defer、panic、recover)

##### Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。一般是抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。

1. 利用recover处理panic指令，defer 必须放在 panic 之前定义，另外 recover 只有在 defer 调用的函数中才有效。否则当panic时，recover无法捕获到panic，无法防止panic扩散。
2. recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。
3. 多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。



## 单元测试

`go test` 是 go语言自带的测试工具， `go test`命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以`_test.go`为后缀名的源代码文件都是 `go test` 测试的一部分，不会被`go build` 编译到最终的可执行文件中。

`go test` 命令会遍历所有的`*_test.go`文件中符合命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。



## Runtime 运行时

golang 的 runtime 是go语言运行所需要的基础设施，核心功能包括以下内容 (主要是调度器和GC):

1. 协程(goroutine)调度(并发调度模型)，内存分配，垃圾回收(GC)
2. 操作系统和cpu相关操作的封装(系统调用，信号处理，寄存器操作，原子操作等)， CGO
4. 使得 golang 可以支持如 debug (排查问题)、pprof (性能分析)、trace (抓取异常事件信息)、race (竞态关系检查) 的检测
5. 支持 golang 的内置类型 channel、map、slice、string等的实现



## MPG 协程调度模型

- 当 Go 程序启动时，它会为主机上标识的每个虚拟核心提供一个逻辑处理器 `P` (logical processor)。 比如当前的处理器是 4 核 8 线程，那么这将告诉 Go 程序有 8 个虚拟核心可用于并行执行系统线程。

- 每个 `P` 都被分配一个系统线程 `M` 。 `M` 代表机器（machine），它仍然是由操作系统管理的，操作系统负责将线程放在一个核心上执行。这意味着当一个4 核 8 线程的机器上运行 Go 程序时，有 8 个线程可以执行工作，每个线程单独连接到一个 `P`。

- 每个 Go 程序都有一个初始 `G`。 `G` 代表 Go 协程（Goroutine），它是 Go 程序的执行路径。可以将 Goroutines 看作是应用程序级别的线程，它在许多方面与系统线程都相似。正如系统线程在物理核心上进行上下文切换一样，Goroutines 在 `M` 上进行上下文切换。

- Go 调度器中有两个不同的运行队列：`全局运行队列(GRQ)` 和 `本地运行队列(LRQ)`。每个 `P` 都有一个 `LRQ`，用于管理分配给在当前 `P` 的上下文中执行的 `G`，这些 `G` 轮流被和 `P` 绑定的 `M` 进行上下文切换。`GRQ` 用于尚未分配给 `P` 的 `G`。
- 如果 `P1` 的 `G` 都执行完了。但是还有其他 `G` 处于可运行状态，在 `GRQ` 中有，在 `P2` 的 `LRQ` 中也有。这时 `P1` 就需要窃取 `G`。 顺序是先去 `GRQ` 取。从 `GRQ` 取的 `G ` 数量符合下面的公式：`n = min(len(GQ)/GOMAXPROCS + 1, len(GQ)/2)` 。若没取到，就去 `P2` 中取一半， 如果找不到任何 `G`。任务窃取的好处在于它使 `M` 不会闲着。在窃取任务时，`M` 处于自旋状态。

  

#### 具体流程参考：

[Golang - 调度剖析](https://segmentfault.com/a/1190000016611742)

[GMP原理与调度]([http://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html](http://www.topgoer.com/并发编程/GMP原理与调度.html))



## GC 垃圾回收

[Go GC 怎么标记内存？颜色是什么含义？图解三色标记法](https://www.toutiao.com/i6847366274649948676/)

golang GC 采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法。

从垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象，并用不同的颜色相称：

白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。

灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。

黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

这样三种不变性所定义的回收过程其实是一个波面不断前进的过程，这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。

当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现（着色），这时候波面便开始扩大。当一个对象的所有子节点均完成扫描时，会被着色为黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象为可达对象，即存活；而白色对象为不可达对象，即死亡。这个过程可以视为以灰色对象为波面，将黑色对象和白色对象分离，使波面不断向前推进，直到所有可达的灰色对象都变为黑色对象为止的过程。

gc的过程一共分为四个阶段：

1. 栈扫描（开始时STW）
2. 第一次标记（并发）
3. 第二次标记（STW）
4. 清除（并发）

Go 语言中对 GC 的触发时机存在两种形式：

- 主动触发，通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。

- 被动触发，分为两种方式： 

  a. 使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。 

  b. 使用步调（Pacing）算法，其核心思想是控制内存增长的比例。



## go的继承与多态



## go的并发模型

1. 通过channel通知实现并发控制
2. 通过sync包中的WaitGroup实现并发控制
3. Context上下文实现并发控制



## 栈空间管理

## runtime调度

## 逃逸

如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到——这样指针就成功“逃逸”了。如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中。

内存逃逸的五种情况:

1. 发送指针的指针或值包含了指针到 channel 中，由于在编译阶段无法确定其作用域与传递的路径，所以一般都会逃逸到堆上分配。
2. slices 中的值是指针的指针或包含指针字段。一个例子是类似[] *string 的类型。这总是导致 slice 的逃逸。即使切片的底层存储数组仍可能位于堆栈上，数据的引用也会转移到堆中。
3. slice 由于 append 操作超出其容量，因此会导致 slice 重新分配。这种情况下，由于在编译时 slice 的初始大小的已知情况下，将会在栈上分配。如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上。
4. 调用接口类型的方法。接口类型的方法调用是动态调度 - 实际使用的具体实现只能在运行时确定。考虑一个接口类型为 io.Reader 的变量 r。对 r.Read(b) 的调用将导致 r 的值和字节片b的后续转义并因此分配到堆上。
5. 尽管能够符合分配到栈的场景，但是其大小不能够在在编译时候确定的情况，也会分配到堆上