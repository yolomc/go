# MySQL

### 为什么使用B+树

B-Tree中每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。



### 切分

### 引擎

### 事物

用START TRANSACTION执行一组sql，否则每个查询都会被当做一个事务自动提交。

### 锁

[Mysql加锁过程详解](http://www.cnblogs.com/crazylqy/p/7611069.html)



### 索引

#### 从数据结构角度

　　1、 B+树索引(O(log(n)))

　　2、 hash索引

　　3、 FULLTEXT索引

　　4、 R-Tree索引

#### 从物理存储角度

　　1、 聚集索引

　　2、 非聚集索引

#### 从逻辑角度

　　1、 主键索引：主键索引是一种特殊的唯一索引，不允许有空值

　　2、 普通索引（辅助索引）

　　3、 多列索引（组合索引）

　　4、 唯一索引或者非唯一索引

### 调优

1. 使用索引进行查询的时候，尽量避免使用类型转换、运算函数、表达式等
2. 尽量使用主键查询，而不是其他索引，因为主键查询不会触发**回表**
3. 使用前缀索引
4. 使用索引扫描进行排序（需要使用where条件，且order by 后升降序需保持一致）
5. 范围列可以用索引（最多用一个）
6. 更新频繁、数据区分度不高（80%以下）的字段不宜建立索引
7. 连表查询最好不要超过3张表，join的字段数据类型需要一致
8. 单表别建太多索引，组合索引字段数越少越好

各种 join 的区别

![各种 join 的区别](https://image-static.segmentfault.com/276/780/2767807589-5c122586a23c4_articlex)



## Redis (Remote Dictionary Server)

[面试必备，史上最全Redis总结](https://www.toutiao.com/i6769576430213792268/)

#### 使用redis有哪些好处？

- 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1).
- 支持丰富数据类型，支持string，list，set，sorted set，hash.
- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行.
- 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除.

[Redis的五种数据结构及应用场景](https://www.cnblogs.com/ottll/p/9470480.html)

| 数据结构      | 数据操作                            | 应用场景                                |
| ------------- | ----------------------------------- | --------------------------------------- |
| String        | 字符串、数值、二进制                | session、kv缓存、计数器                 |
| List (双链表) | 栈、队列、数组                      | 消息队列、评论                          |
| Hash          | 哈希表                              | 购物车、详情页、聚集数据 (如数据统计)   |
| Set           | 集合 (无序不重复)                   | 随机事件 (抽奖、验证码)、共同xx、xx推荐 |
| Sorted Set    | 集合 (有序不重复) ziplilst/skiplist | 排行榜、时间排序的内容                  |



#### Redis为什么这么快

1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4. 使用多路I/O复用模型，非阻塞IO；

5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

   

#### Redis持久化

持久化说白了其实就是数据备份，Redis两种方式，分别是**RDB**（默认开启）与AOF（默认关闭，如果开启则只会读取AOF）。

| 持久化     | 时间点          | 特点                                                         |
| ---------- | --------------- | ------------------------------------------------------------ |
| RDB (快照) | 手动或定期执行  | **全量**一次同步内存中所有序列化的二进制数据。同步较慢，恢复快 (与IO读取速度相近)，数据较小 (和真实数据相近)。 |
| AOF (日志) | (趋向于) 实时的 | **增量**同步操作指令，同步较快，数据量随时间增加而增多，需定期进行AOF文件重写 (先把现有数据RDB，再继续追加AOF)，以便减小日志文件。 |

[讲你理解的Redis的持久化机制(RDB、AOF)](https://www.toutiao.com/i6793317264385901060/)

### redis挂了怎么办?

### redis集群，哨兵，持久化，事务

### 为什么使用跳表？ 

跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。 跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。



## MongoDB

为什么 Mongodb 索引用 B 树，而 MySQL 用 B+ 树：https://mp.weixin.qq.com/s/kRG8osOgLIenr7UeEqT7aQ



## ElasticSearch



